s.shape
s=matrix(c(1:15),1,3)
c(1:15)
View(s)
dim(s)
dim(s)[1]
dim(s)[-1]
dim(s)[0]
dim(s)[-2]
length(s)[1]
x=[2,3,4,6,8]
x %%2
print("hello"+str(5))
str(5)
toString(5)
print("hello"+toString(5))
print(c("hello",toString(5))
s
s=c("hello",toString(5)
)
s
print(c("hello",toString(5)))
print("hello"+toString(5))
paste("hello",toString(5))
install.packages("R.matlab")
library(R.matlab)
install.packages("getOption")
install.packages("isOpen")
install.packages(c("R.methodsS3", "R.oo"))
library(R.oo)
library(R.oo)
install.packages("qrmtools")
install.packages("skedastic")
n=5
type(n)
typeof(n)
n=5
as.integer(5)
s <- list()
dim(S)
dim(s)
length(s)
append(s,1)
s=append(s,1)
s=append(s,5)
View(s)
length(list_prime)
list_prime <- list()
length(list_prime)
v=1
v=2
1:2
2:2
3:2
3:1:2
range(2,5,1)
range(2,5)
vv=range(2,5)
3 in vv
(3 in vv)
vv
v=5
1:v
v=12
for (vv in 2:v)
{
print(toString(vv))
}
5//2
5%//%2
5//2
5%%2
vv=2
v=12
v%%vv
v%%vv==0
(2>3 && 3>1)
(2<3 && 3>1)
prev_divider
prev_divider=NA
is.na(prev_divider)
n <- as.integer(n)
list_prime <- list()
v=1
while (length(list_prime)<=n)
{
v <- v+1
vv=1
prev_divider=NA
while (is.na(prev_divider))
{
vv=vv+1
if (v%%vv==0)
{
prev_divider=TRUE
if (v==vv)
{
list_prime=append(list_prime,v)
}
}
}
}
View(list_prime)
View(list_prime)
fun1 <- function(n)
{
n <- as.integer(n)
list_prime <- list()
v=1
while (length(list_prime)<n)
{
v <- v+1
vv=1
prev_divider=NA
while (is.na(prev_divider))
{
vv=vv+1
if (v%%vv==0)
{
prev_divider=TRUE
if (v==vv)
{
list_prime=append(list_prime,v)
}
}
}
}
}
simpleError("ERROR in n")
simpleError("ERROR in n",call=(n<1))
simpleError("ERROR in n",call=(3<1))
simpleError("ERROR in n",call=(0<1))
signalCondition((3>1))
signalCondition((3<1))
stop(errorCondition("Wrong choice of n"))
fun1 <- function(n)
{
n <- as.integer(n)
if (n<1)
{
stop(errorCondition("Wrong choice of n"))
}
list_prime <- list()
v=1
while (length(list_prime)<n)
{
v <- v+1
vv=1
prev_divider=NA
while (is.na(prev_divider))
{
vv=vv+1
if (v%%vv==0)
{
prev_divider=TRUE
if (v==vv)
{
list_prime=append(list_prime,v)
}
}
}
}
return (list_prime)
}
n=10
fun1(1)
fun1(2)
fun1(3)
fun1(0)
fun1(1)
print(paste("The list of ",toString(n)," first prime numbers are"))
prime_list=fun1(n)
View(prime_list)
print(paste("The list of ",toString(n)," first prime numbers is in variable 'prime_list'"))
print(prime_list)
prime_list
n=readline("Please enter integer n>0: ")
float(n)
as.double(n)
source("~/Documents/Rstudio/prime_n.R")
c=1
c+=1
## This script prints out the first n prime numbers
# The script is optimised for the number of trials before identifying a
# number as prime
# Script by Arman Hassanniakalager GitHub @hkalager
n = 10
fun1 <- function(n)
{
n <- as.integer(n)
if (n<1)
{
stop(errorCondition("Wrong choice of n"))
}
list_prime <- list()
v=1
while (length(list_prime)<n)
{
v <- v+1
vv=1
prev_divider=NA
cap_vv=v
while (is.na(prev_divider) && vv<cap_vv)
{
vv=vv+1
if (length(list_prime)>0)
{
highest_prime <- tail(list_prime,1)[[1]]
cap_vv <- min(as.integer(v/2),highest_prime)
}
if (v%%vv==0)
{
prev_divider=TRUE
vv=vv-1
}
}
if (vv>=cap_vv || v==2)
{
list_prime=append(list_prime,v)
}
}
return (list_prime)
}
prime_list=fun1(n)
print(paste("The list of ",toString(n)," first prime numbers is in variable 'prime_list'"))
View(prime_list)
View(prime_list)
## This script prints out the first n prime numbers
# The script is optimised for the number of trials before identifying a
# number as prime
# Script by Arman Hassanniakalager GitHub @hkalager
n = 20
fun1 <- function(n)
{
n <- as.integer(n)
if (n<1)
{
stop(errorCondition("Wrong choice of n"))
}
list_prime <- list()
v=1
while (length(list_prime)<n)
{
v <- v+1
vv=1
prev_divider=NA
cap_vv=v
while (is.na(prev_divider) && vv<cap_vv)
{
vv=vv+1
if (length(list_prime)>0)
{
highest_prime <- tail(list_prime,1)[[1]]
cap_vv <- min(as.integer(v/2),highest_prime)
}
if (v%%vv==0)
{
prev_divider=TRUE
vv=vv-1
}
}
if (vv>=cap_vv || v==2)
{
list_prime=append(list_prime,v)
}
}
return (list_prime)
}
prime_list=fun1(n)
print(paste("The list of ",toString(n)," first prime numbers is in variable 'prime_list'"))
View(prime_list)
View(prime_list)
source("~/Documents/GitHub/misc/term_optimise.R")
source("~/Documents/GitHub/misc/term_optimise.R")
# Key inputs
setwd('~/Documents/GitHub/misc')
term_db <- read.csv('term_quotes.csv') # the database
penalty_factor <- 1
# First replicate the series based on target series variations from the provided
# starting points
date_ser <- term_db$date_base
date_ser <- as.Date(date_ser,format="%d/%m/%Y")
first_na <- which(is.na(term_db$price_build))[1]
size_ser <- dim(term_db)[1]
for (s in (first_na:size_ser))
{
term_db$price_build[s]=(term_db$Reference.curve[s]/term_db$Reference.curve[s-1])*term_db$price_build[s-1]
}
cor_0=cor(term_db$price_build,term_db$Reference.curve)
date_ser[1]
date_ser[1].year
year(date_ser[1])
library(lubridate)
install.packages("lubridate")
library(lubridate)
year(date_ser[1])
which((year(date_ser)==2021 && month(date_ser)>=4 && month(date_ser)<=6))
(year(date_ser)==2021 && month(date_ser)>=4 && month(date_ser)<=6)
year(date_ser)
year(date_ser)==2021 && month(date_ser)>=4
year(date_ser)==2021
year(date_ser)==2021 && month(date_ser)>=4
month(date_ser)>=4
all(year(date_ser)==2021,month(date_ser)>=4,month(date_ser)<=6)
all(year(date_ser)==2021,month(date_ser)>=4)
{year(date_ser)==2021,month(date_ser)>=4,month(date_ser)<=6}
year(date_ser)==2021,month(date_ser)>=4
year(date_ser)==2021 & month(date_ser)>=4
year(date_ser)==2021 & month(date_ser)>=4 & month(date_ser)<=6
q22021_rng=which(year(date_ser)==2021 & month(date_ser)>=4 & month(date_ser)<=6)
q22021_rng
q32021_rng=which(year(date_ser)==2021 & month(date_ser)>=7 & month(date_ser)<=9)
q32021_rng
q22021_rng[-1]
q22021_rng=which(year(date_ser)==2021 & month(date_ser)>=4 & month(date_ser)<=6)
q22021_build_avg <- mean(term_db$price_build[q22021_rng])
q22021_build_adj_factor <- term_db$mean_Q[1]/q22021_build_avg
q22021_build_adj_diff <- term_db$mean_Q[1]-q22021_build_avg
for (s in q22021_rng[-1])
{
term_db$price_build[s] <- term_db$price_build[s]+q22021_build_adj_diff/2
}
q42021_rng=which(year(date_ser)==2021 & month(date_ser)>=10 & month(date_ser)<=12)
q42021_build_avg <- mean(term_db$price_build[q42021_rng])
q42021_build_adj_factor <- term_db$mean_Q[3]/q42021_build_avg
q42021_rng
q12022_rng=which(year(date_ser)==2022 & month(date_ser)<=3)
q12022_rng
q22021_rng
length(q12022_rng)
last_observed=q12022_rng[length(q12022_rng)]
last_observed
last_observed_idx=q12022_rng[length(q12022_rng)]
last_observed_idx+1:length(term_db$price_build)
length(term_db$price_build)
last_observed_idx+1:length(term_db$price_build)
(last_observed_idx+1):length(term_db$price_build
)
# This code tracks and replicates a target term structure provided for time
# horizons of next month to several years ahead. The adjustment is deemed
# necessary due to market prices over certain periods. See Wiki tab for more
# information on the aim and scope of this project.
# The objective function is defined to maximize the correlation between the
# constructed curve and reference curve while penalising deviation from Mean
# The penalty term is given by variable "penalty_factor"
# Key inputs
setwd('~/Documents/GitHub/misc')
term_db <- read.csv('term_quotes.csv') # the database
penalty_factor <- 1
# First replicate the series based on target series variations from the provided
# starting points
library(lubridate)
date_ser <- term_db$date_base
date_ser <- as.Date(date_ser,format="%d/%m/%Y")
first_na <- which(is.na(term_db$price_build))[1]
size_ser <- dim(term_db)[1]
for (s in (first_na:size_ser))
{
term_db$price_build[s]=(term_db$Reference.curve[s]/term_db$Reference.curve[s-1])*term_db$price_build[s-1]
}
cor_0=cor(term_db$price_build,term_db$Reference.curve)
q22021_rng=which(year(date_ser)==2021 & month(date_ser)>=4 & month(date_ser)<=6)
q22021_build_avg <- mean(term_db$price_build[q22021_rng])
q22021_build_adj_factor <- term_db$mean_Q[1]/q22021_build_avg
q22021_build_adj_diff <- term_db$mean_Q[1]-q22021_build_avg
for (s in q22021_rng[-1])
{
term_db$price_build[s] <- term_db$price_build[s]+q22021_build_adj_diff/2
}
q32021_rng=which(year(date_ser)==2021 & month(date_ser)>=7 & month(date_ser)<=9)
q32021_build_avg <- mean(term_db$price_build[q32021_rng])
q32021_build_adj_factor <- term_db$mean_Q[2]/q32021_build_avg
for (s in q32021_rng)
{
term_db$price_build[s] <- term_db$price_build[s]*q32021_build_adj_factor
}
q42021_rng=which(year(date_ser)==2021 & month(date_ser)>=10 & month(date_ser)<=12)
q42021_build_avg <- mean(term_db$price_build[q42021_rng])
q42021_build_adj_factor <- term_db$mean_Q[3]/q42021_build_avg
for (s in q42021_rng)
{
term_db$price_build[s] <- term_db$price_build[s]*q42021_build_adj_factor
}
q12022_rng=which(year(date_ser)==2022 & month(date_ser)<=3)
q12022_build_avg <- mean(term_db$price_build[q12022_rng])
q12022_build_adj_factor <- term_db$mean_Q[4]/q12022_build_avg
for (s in q12022_rng)
{
term_db$price_build[s] <- term_db$price_build[s]*q12022_build_adj_factor
}
adj_factor_rem=mean(c(q12022_build_adj_factor,q42021_build_adj_factor,q32021_build_adj_factor
,q22021_build_adj_factor))
last_observed_idx=q12022_rng[length(q12022_rng)]
for (s in (last_observed_idx+1):size_ser)
{
term_db$price_build[s] <- term_db$price_build[s]*adj_factor_rem
}
cor0=cor(term_db$price_build,term_db$Reference.curve)
x0=term_db$price_build
mean0=mean(x0[3:last_observed_idx])
mean1=mean(x0[(last_observed_idx+1):size_ser])
fun1 <- function (x)
{ y=term_db$Reference.curve
x1 <- x
x1[1:2]=x0[1:2]
return (-cor(x1,y)+penalty_factor*(abs(mean(x1[3:13])-mean0)))
##return (-cor(x1,y)+penalty_factor*(abs(mean(x1[3:13])-mean0))+
##        penalty_factor/4*(abs(mean(x1[14:length(x1)])-mean1)))
}
res <- optim(x0,fun1)
print('Printing the optimal series and objective function value')
res
opt_ser <- res$par[1:length(x0)]
opt_cor <- cor(opt_ser,term_db$Reference.curve)
paste("Initial correlation ",toString(round(cor0,digits = 3)),
" vs optimised series correlation ",toString(round(opt_cor,digits = 3)))
## Plot it!
y_min <- min(min(x0),min(term_db$Reference.curve))
y_max <- max(max(x0),max(term_db$Reference.curve))
plot(date_ser,x0,type="l",col="blue",xlab="Time",ylab="",ylim=c(y_min,y_max))
par(new=TRUE)
plot( date_ser, opt_ser, type="l", col="red",xlab="",ylab="price",ylim=c(y_min,y_max),axes=FALSE)
par(new=TRUE)
plot( date_ser, term_db$Reference.curve, type="l", col="green",xlab="",ylab="price",ylim=c(y_min,y_max),axes=FALSE)
first_na
# A sample R script for forecasting a term-structure in a random financial market
# This code tracks and replicates a target term structure provided for time
# horizons of next month to several years ahead. The adjustment is deemed
# necessary due to market prices over certain periods. See Wiki tab for more
# information on the aim and scope of this project.
# The objective function is defined to maximize the correlation between the
# constructed curve and reference curve while penalising deviation from Mean
# The penalty term is given by variable "penalty_factor"
# Scripts by Arman Hassanniakalager GitHub @hkalager
# Last reviewed 10 March 2022
# Key inputs
setwd('~/Documents/GitHub/misc')
term_db <- read.csv('term_quotes.csv') # the database
penalty_factor <- 1
# First replicate the series based on target series variations from the provided
# starting points
library(lubridate)
date_ser <- term_db$date_base
date_ser <- as.Date(date_ser,format="%d/%m/%Y")
first_na <- which(is.na(term_db$price_build))[1]
size_ser <- dim(term_db)[1]
for (s in (first_na:size_ser))
{
term_db$price_build[s]=(term_db$Reference.curve[s]/term_db$Reference.curve[s-1])*term_db$price_build[s-1]
}
cor_0=cor(term_db$price_build,term_db$Reference.curve)
q22021_rng=which(year(date_ser)==2021 & month(date_ser)>=4 & month(date_ser)<=6)
q22021_build_avg <- mean(term_db$price_build[q22021_rng])
q22021_build_adj_factor <- term_db$mean_Q[1]/q22021_build_avg
q22021_build_adj_diff <- term_db$mean_Q[1]-q22021_build_avg
for (s in q22021_rng[-1])
{
term_db$price_build[s] <- term_db$price_build[s]+q22021_build_adj_diff/2
}
q32021_rng=which(year(date_ser)==2021 & month(date_ser)>=7 & month(date_ser)<=9)
q32021_build_avg <- mean(term_db$price_build[q32021_rng])
q32021_build_adj_factor <- term_db$mean_Q[2]/q32021_build_avg
for (s in q32021_rng)
{
term_db$price_build[s] <- term_db$price_build[s]*q32021_build_adj_factor
}
q42021_rng=which(year(date_ser)==2021 & month(date_ser)>=10 & month(date_ser)<=12)
q42021_build_avg <- mean(term_db$price_build[q42021_rng])
q42021_build_adj_factor <- term_db$mean_Q[3]/q42021_build_avg
for (s in q42021_rng)
{
term_db$price_build[s] <- term_db$price_build[s]*q42021_build_adj_factor
}
q12022_rng=which(year(date_ser)==2022 & month(date_ser)<=3)
q12022_build_avg <- mean(term_db$price_build[q12022_rng])
q12022_build_adj_factor <- term_db$mean_Q[4]/q12022_build_avg
for (s in q12022_rng)
{
term_db$price_build[s] <- term_db$price_build[s]*q12022_build_adj_factor
}
adj_factor_rem=mean(c(q12022_build_adj_factor,q42021_build_adj_factor,q32021_build_adj_factor
,q22021_build_adj_factor))
last_observed_idx=q12022_rng[length(q12022_rng)]
for (s in (last_observed_idx+1):size_ser)
{
term_db$price_build[s] <- term_db$price_build[s]*adj_factor_rem
}
cor0=cor(term_db$price_build,term_db$Reference.curve)
x0=term_db$price_build
mean0=mean(x0[first_na:last_observed_idx])
mean1=mean(x0[(last_observed_idx+1):size_ser])
fun1 <- function (x)
{ y=term_db$Reference.curve
x1 <- x
x1[1:2]=x0[1:2]
return (-cor(x1,y)+penalty_factor*(abs(mean(x1[first_na:last_observed_idx])-mean0)))
}
res <- optim(x0,fun1)
print('Printing the optimal series and objective function value')
res
opt_ser <- res$par[1:length(x0)]
opt_cor <- cor(opt_ser,term_db$Reference.curve)
paste("Initial correlation ",toString(round(cor0,digits = 3)),
" vs optimised series correlation ",toString(round(opt_cor,digits = 3)))
## Plot it!
y_min <- min(min(x0),min(term_db$Reference.curve))
y_max <- max(max(x0),max(term_db$Reference.curve))
plot(date_ser,x0,type="l",col="blue",xlab="Time",ylab="",ylim=c(y_min,y_max))
par(new=TRUE)
plot( date_ser, opt_ser, type="l", col="red",xlab="",ylab="$",ylim=c(y_min,y_max),axes=FALSE)
par(new=TRUE)
plot( date_ser, term_db$Reference.curve, type="l", col="green",xlab="",ylab="$",ylim=c(y_min,y_max),axes=FALSE)
